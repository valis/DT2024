\import Data.Bool
\import Data.List \hiding (::,nil)
\import Paths
\import lect03

-- 1. \record Pair, \new, \cowith, проекции, паттерн матчинг.

-- Records -- это \Sigma-типы с именованными полями.
\record NatPair'
  | fst : Nat
  | snd : Nat

-- Любое поле -- это просто функция, которая первым неявным параметром прнимает инстанс рекорда.
-- fst : \Pi {x : NatPair'} -> Nat
\func foo (p : NatPair') => fst {p}

-- Поля также лежат внутри модуля, соответствующего рекорду.
\func foo' (p : NatPair') => NatPair'.fst {p}

-- Можно использовать синтаксис через точку, но только если слева от точки стоит переменная и ее тип указан явно.

\func bar (p : NatPair') => p.snd

-- (f x).snd -- Так нельзя. Это можно заменить одним из следующих способов:
-- \lam x => x.snd
-- \let e : NatPair' => f x \in e.snd
-- snd {f x}

-- Следующий код не будет тайпчекаться, так как тип p не указан явно.
-- \func baz {p p' : NatPair'} (q : p = p') => pmap (\lam p => p.fst) q

-- Для создания элемента рекорда можно использовать ключевое слово \new.
\func zeroPair => \new NatPair' {
  | fst => 0
  | snd => 0
}

\func tupleEta (p : \Sigma Nat Nat) : (p.1,p.2) = p
  => idp

-- Для рекордов есть эта-эквивалентность.
\func etaNatPair' (p : NatPair') : p = \new NatPair' { | fst => p.fst | snd => p.snd }
  => idp

\func foobar (p : NatPair') => fst {p} Nat.+ p.snd

\func foobar' (p : NatPair') : Nat
  | (a,b) => a Nat.+ b

-- Вместо \new можно использовать ключевое слово \cowith.
-- При этом мы говорим, что функция определяется при помощи копаттерн матчинга.
-- Для этого функция должна возвращать элемент некоторого рекорда.
-- После ключевого слова \cowith мы пишем список полей рекорда и значений, соответствующих этим полям.
\func zeroPair' : NatPair' \cowith
  | fst => 0
  | snd => 0

-- 2. Частичная реализация.

-- Можно использовать частичную реализацию классов.
-- Если C -- рекорд с полями f_1, ... f_n, то мы можем писать C { | f_{i_1} => e_{i_1} ... | f_{i_k} => e_{i_k} } для рекорда, где часть полей реализована указанным образом.
-- Например, NatPair' { | fst => 0 } -- это тип рекордов, где первое поле равно 0.
-- Такой тип эквивалентен просто типу второго поля, то есть натуральным числам.
-- Мы будем называть такие типы анонимными расширениями.
\func PartialEx : \Type => NatPair' { | fst => 0 }

\func ppp : NatPair' { | fst => 0 } => \new NatPair' { | snd => 1 }

\func ppp'' : NatPair' { | fst => 0 } => \new NatPair' { | fst => 0 | snd => 1 }

-- На рекордах (и их анонимных расширениях) есть отношение подтипизации.
-- Если p имеет тип C { ... }, где реализованы какие-то поля, то он имеет и тип C { ... }, где реализовано подмножество этих полей.
-- Например:
\func partial (p : NatPair' { | fst => 0 | snd => 1 }) : PartialEx => p

\func PartialEx' => NatPair' { | fst => 3 | snd => 7 }

-- Оператор \new принимает произвольное выражение, которое должно вычисляться либо в рекорд, либо в его анонимное расширение.
-- Причем, должно быть верно, что все поля в этом рекорде/расширении реализованы.
\func new => \new PartialEx'
-- \new E : E
-- NatPair' { } == NatPair'

-- 3. Параметры, видимость полей.

-- Рекорды могут быть параметризованы.
\record Pair (A B : \Type)
  | fst_ : A
  | snd_ : B

-- Создавать элементы такого рекорда можно при помощи \new или \cowith как и раньше.
\func pairExample : Pair Nat (Nat -> Nat)
                 -- Pair { | A => Nat | B => Nat -> Nat }
  => \new Pair { | fst_ => 1 | snd_ x => x }

-- На самом деле параметры рекорда являются его полями.
-- Пример выше эквивалентен следующему коду:
\func pairExample'
  => \new Pair { | A => Nat | B => Nat -> Nat | fst_ => 1 | snd_ x => x }

\func pairExample''
  => \new Pair Nat (Nat -> Nat) 1 (\lam x => x)

-- Мы можем все поля рекорда определить как параметры.
-- Например, следующий тип эквивалентен типу NatPair, определенному выше:
\record NatPair'' (fst'' snd'' : Nat)

-- Мы можем всё еще использовать \new и \cowith для него:
\func natPair''ex => \new NatPair'' {
  | fst'' => 0
  | snd'' => 0
}

-- И наоборот, тип Pair эквивалентен следующему типу:
{-
\record Pair'
  | A : \Type
  | B : \Type
  | fst_ : A
  | snd_ : B
-}

-- Единственное отличие параметров и полей -- это то, что параметры по умолчанию не видны снаружи от класса, а поля видны.
-- Мы всё еще можем сделать параметры видимыми при помощи инструкции \open:
-- \open NatPair''
-- Либо мы можем обращаться к ним по полному имени:
\func natPair''foo => NatPair''.fst''

-- Верно и орабтное.
-- Если рекорд объявлен с полями, мы всё еще можем передавать их как аргументы при вызове:
\func natPairEx => \new NatPair' 0 0

-- То есть между полями и параметрами рекорда нет почти никакой разницы.

-- 4. Dependent records, тип положительных натуральных чисел.

\func isPos (n : Nat) : Bool
  | 0 => false
  | suc _ => true

-- Рекорды могут быть зависимыми, то есть типы полей могут зависеть от предыдущих полей.
-- Таким образом, рекорды полностью эквивалентны \Sigma-типам.

-- Например тип положительных натуральных чисел, который в теории множеств записывается как { n : Nat | T (isPos n) }, можно определить либо как \Sigma-тип \Sigma (n : Nat) (T (isPos n)), либо как рекорд:
\record PosNat (n : Nat) (p : So (isPos n))

-- 5. Monoid.

-- Еще один пример зависимых рекордов -- это тип моноидов.
-- Вместо ключевого слова \record мы использовали \class.
-- Классы почти полностью эквивалентны рекордам, но они предоставляют некоторую дополнительную функциональность.
\class Monoid (A : \Set)
  | id : A
  | \infixl 6 * : A -> A -> A
  | *-assoc (x y z : A) : (x * y) * z = x * (y * z)
  -- equivalent to *-assoc : \Pi (x y z : A) -> (x * y) * z = x * (y * z)
  | id-left (x : A) : id * x = x
  | id-right (x : A) : x * id = x

-- Monoid
-- Monoid Nat
-- Monoid Nat 0 Nat.+

-- При наследовании классов можно реализовывать некоторые поля, чтобы не приходилось их реализовывать в каждом инстансе.
\class CommMonoid \extends Monoid
  | *-comm (x y : A) : x * y = y * x
  | id-right x => *-comm x id *> id-left x

\class CommMonoid' \extends Monoid {
  | *-comm' (x y : A) : x * y = y * x
  \default id-right x => *-comm' x id *> id-left x
  \default id-left x => *-comm' id x *> id-right x
}

-- 6. Классы, инстансы.

-- foo :: Eq a => a -> a

-- Отличие классов от рекодов заключается в том, что для классов реализован алгоритм вывода их инстансов наподобие того, как это сделано в хаскелле.
-- Мы можем определить инстанс класса следующим образом:

\instance NatMonoid : Monoid Nat
  | id => 0
  | * => Nat.+
  | *-assoc => +-assoc
  | id-left _ => idp
  | id-right _ => idp

\func example => (1 * 2) * 3

\instance NatMonoid' : Monoid Nat
  | id => 1
  | * => Nat.*
  | *-assoc => {?}
  | id-left => {?}
  | id-right => {?}

-- \instance NatMonoid'' : Monoid Nat 1 (Nat.*) {?} {?} {?}

-- Это не будет работать, т.к. он выбирает первый подходящий instance Monoid.
-- \func foooo (x : Nat) : 1 Nat.* x = x => id-left x
\func foooo' (x : Nat) : 0 Nat.+ x = x => id-left x

-- Инстансы являются обычными функциями.
\func instEx => NatMonoid.id-left

\func instExF (M : Monoid) => M.id

\func instExF_ {M : Monoid} (x y z : M) => x * (y * z)

\func instEx' => instExF NatMonoid'

-- Поля класса имеют такой же тип как и поля рекорда:
-- * {M : Monoid} (x y : M.A) : M.A

-- Когда мы обращаемя к полю класса, первый неявный ищется среди доступных инстансов.
-- Доступными считаются только те инстансы, в которых классифицирующее поле равно подходящему типу.
-- Сейчас поле считается классифицирующим, если оно является первым явным параметром класса.
-- Например, в следующем примере первый неявный аргумент для * будет равен NatMonoid, так как это единственный инстанс моноида, в котором классифицирующее поле A равно Nat, типу аргументов этой функции.
\func f (x y : Nat) => x * y

\record R (x y : Nat) {
  \func test => x Nat.+ y
} \where {
  \func test' {this : R} => this.x Nat.+ this.y
}

\class Map \noclassifying {A B : \Type} (f : A -> B) {
  \func isInj : \Type => \Pi (x y : A) -> f x = f y -> x = y
  \func prop1 (p : isInj) : 0 = 0 => {?}
  \func prop2 (p : isInj) : 1 = 1 => {?}
}

-- Классы можно использовать как классы типов в хаскелле.
-- Например, класс Eq можно записать следующим образом:
\class Eq' (A : \Type)
  | \infix 3 ==' (x y : A) : Bool

-- Функцию refl, которая в хаскеле записывается следующим образом, можно описать двумя способами.
-- refl :: Eq a => a -> Bool
-- refl x = x ==' x
\func refl {A : \Type} {e : Eq' A} (a : A) => a ==' a

\func refl' {E : Eq'} (a : E) => a ==' a

-- \func xxxx => refl 1

-- 7. Classifying field.

-- Классицирующее поле обадает рядом дополнительных свойств.
-- Например, если в некотором месте ожидается элемент типа X, а передается элемент класса C, классифицирующее поле которого имеет тип X, оно будет неявно вставленно вместо этого значения.
-- Например, в следующем примере вместо M будет вставлено M.A, так как в этом месте ожидается элемент типа \Type, а передается элемент типа Monoid.
\func foobarbaz {M : Monoid} (x : M) => x

\data XXX | con

-- Кроме классифицирующих полей можно создавать собственные функции, преобразующии элемент одного типа в другой.
-- Для этого нужно в \where блоке к классу, рекорду или \data определить функцию при помощи ключевого слова \coerce вместо ключевого слова \func.
\data YYY | con' XXX Nat | con''
  \where {
    -- Можно преобразовывать либо к данному типу.
    -- При этом, функция должна возвращать элемент этого типа.
    \use \coerce fromXXX (x : XXX) => con' x 0

    -- Либо можно преобразовывать из данного типа.
    -- При этом функция должна принимать элемент данного типа в качестве последнего параметра.
    \use \coerce toXXX (y : YYY) => con
  }

\func fff (y : YYY) => y

-- Теперь элементы типа XXX неявно преобразуются к элементам типа YYY при помощи функции fromXXX.
\func ggg => fff con

-- Преобразование натуральных чисел к Int выполнено именно таким образом:
\func hhh : Int => 0

-- 8. \extends, diamond problem.

-- Рекорды и классы можно наследовать.
\record Base (A : \Type)

\record Base' (A : \Type)

\record X \extends Base
  | a : A

\record Y \extends Base'
  | b : A

-- При этом имена и типы полей ни на что не влияют.
-- В рекорде Z будет четыре поля: Base.A, Base'.A, a и b.
\record Z \extends X, Y

\func zzz => \new Z {
  | A => {?}
  | a => {?}
  | Base'.A => {?}
  | b => {?}
}

\func zzzz (z : Z) => Base'.A {z}

-- Но в рекорде Z' будет только три поля, так как поле A из рекорда Base является одним и тем же и в рекорде X', и в рекода Y':

\record X' \extends Base
  | aa : A

\record Y' \extends Base
  | bb : A

\record Z' \extends X', Y'

-- Например, тип колец можно реализовать следующим образом.
\class AbGroup \extends CommMonoid {
  | inverse : A -> A
  | inv-left (x : A) : inverse x * x = id
  | inv-right (x : A) : x * inverse x = id
}

-- Чтобы отличать структуру сложения от структуры умножения, мы не наследуемся от моноида, но добавляем его как поля.
-- При этом, подлежащий тип и группы по сложению и моноида по умножению должен быть одинаковый.
-- Поэтому мы указываем в типе mulMonoid, что поле подлежащего типа реализовано определенным образом, а конкретно как подлежащий тип группы по сложению.
\class Ring \extends AbGroup
  | mulMonoid : Monoid A

-- Определим еще один тип абелевых групп, который не наследует моноиды.
\class AbGroup' (A : \Set) {
  -- Здесь нужно перечислить все поля из Monoid, CommMonoid и AbGroup.
}

-- Если мы попытаеся определить тип колец следующим образом, то у нас ничего не получится, так как структуры сложения и умножения будут совпадать.
\class Ring' \extends AbGroup', Monoid
  | Monoid.A => AbGroup'.A

-- 9. Functor.

-- Еще один пример: класс функторов.
\class Functor (F : \Set -> \Set)
  | fmap {A B : \Set} : (A -> B) -> F A -> F B
  | fmap-id {A : \Set} (x : F A) : fmap (\lam a => a) x = x
  | fmap-comp {A B C : \Set} (f : A -> B) (g : B -> C) (x : F A) : fmap (\lam a => g (f a)) x = fmap g (fmap f x)

\instance ListFunctor_ : Functor List
  | fmap => fmap
  | fmap-id => {?}
  | fmap-comp => {?}
  \where {
    \func fmap {A B : \Set} (f : A -> B) (xs : List A) : List B \elim xs
      | List.nil => {?}
      | a List.:: xs => {?}
  }

\instance ListFunctor : Functor List
  | fmap {A B : \Set} (f : A -> B) (xs : List A) : List B \elim xs {
    | List.nil => List.nil
    | a List.:: xs => f a List.:: fmap f xs
  }
  | fmap-id {A : \Set} (xs : List A) : fmap (\lam a => a) xs = xs \elim xs {
    | List.nil => idp
    | a List.:: xs => pmap (a List.::) (fmap-id xs)
  }
  | fmap-comp {A B C : \Set} (f : A -> B) (g : B -> C) (xs : List A) : fmap (\lam a => g (f a)) xs = fmap g (fmap f xs) \elim xs {
    | List.nil => idp
    | a List.:: xs => pmap (_ List.::) (fmap-comp f g xs)
  }

-- 10. Arrays

\data D (n : Nat) | con__ (Fin n -> D n)

-- Vec A n == (Fin n -> A)

\data Tree (A : \Type) (n : Nat)
  | leaf A
  | branch (Fin n -> Tree A n)

\func height {A : \Type} {n : Nat} (t : Tree A n) : Nat \elim t
  | leaf a => 0
  | branch f => \let xxx i => height (f i) \in {?}

\record Array' (A : \Type) (len : Nat) (\coerce at : Fin len -> A)

-- Array' A n == Vec A n
-- Array' A == List A

\func func1 : Fin 3 -> Nat
  => \lam j => \case j \with {
    | 0 => 1
    | 1 => 2
    | 2 => 3
  }

\func func2 : Fin 3 -> Nat
  => \lam j => \case j \with {
    | 0 => 1
    | suc j => \case j \with {
      | 0 => 2
      | 1 => 3
    }
  }

\func array1 : Array Nat \cowith
  | len => 3
  | at j => \case j \with {
    | 0 => 1
    | 1 => 2
    | 2 => 3
  }

\func array2 : Array Nat \cowith
  | len => 3
  | at j => \case j \with {
    | 0 => 1
    | suc j => \case j \with {
      | 0 => 2
      | 1 => 3
    }
  }

\func ok : array1 = array2 => idp

\func map' {A B : \Type} (f : A -> B) (l : Array A) : Array B \elim l
  | nil => nil
  | :: a arr => f a :: map' f arr

\func map {A B : \Type} (f : A -> B) (l : Array A) : Array B
  => \lam j => f (l j)